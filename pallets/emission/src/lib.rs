//! # Sanctuary Emission Pallet (v2.0)
//!
//! A **stateless** pallet that distributes block rewards according to a
//! pre-computed sigmoid emission schedule.
//!
//! ## Design Philosophy
//!
//! Unlike the complex ASM (Adaptive Scarcity Mechanism) in v1.0, this pallet
//! uses a simple lookup table approach:
//!
//! 1. Emission schedule is pre-computed off-chain (Python script)
//! 2. Reward per era is stored in a constant array
//! 3. On each block, the pallet looks up the current era's reward
//! 4. Reward is minted and given to the block author
//!
//! ## Why Pre-computed?
//!
//! - **Deterministic**: No floating-point, no approximation errors
//! - **Auditable**: Anyone can verify the exact emission schedule
//! - **Simple**: No complex on-chain math, just array lookup
//! - **Gas-efficient**: O(1) lookup vs O(n) computation
//!
//! ## Emission Curve
//!
//! The sigmoid function produces a bell-curve reward distribution:
//! - Years 0-5: Rewards increase (early adopter incentive)
//! - Year 10: Peak rewards (~0.66 SANC/block)
//! - Years 15-20: Rewards decrease (scarcity phase)
//!
//! Total supply asymptotically approaches 13,817,580 SANC (π × e × φ × 10^6)

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

pub use pallet::*;

/// Pre-computed emission table (generated by scripts/generate_curve.py)
mod emission_table;
pub use emission_table::*;

#[frame_support::pallet]
pub mod pallet {
    use super::*;
    use frame_support::{
        pallet_prelude::*,
        traits::{Currency, FindAuthor},
    };
    use frame_system::pallet_prelude::*;

    /// The balance type of this pallet
    pub type BalanceOf<T> =
        <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

    /// Negative imbalance (newly created tokens)
    pub type NegativeImbalanceOf<T> = <<T as Config>::Currency as Currency<
        <T as frame_system::Config>::AccountId,
    >>::NegativeImbalance;

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    /// Configuration trait for the emission pallet
    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// The overarching runtime event type
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

        /// Currency for reward distribution
        type Currency: Currency<Self::AccountId>;

        /// Find the author of the current block (validator who gets reward)
        type FindAuthor: FindAuthor<Self::AccountId>;

        /// Weight information
        type WeightInfo: WeightInfo;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // NO STORAGE - This pallet is stateless!
    // The emission table is a compile-time constant, not runtime storage.
    // ═══════════════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════════════
    // EVENTS
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Block reward was minted and distributed to the block author
        RewardMinted {
            block_number: BlockNumberFor<T>,
            era: u32,
            author: T::AccountId,
            reward: BalanceOf<T>,
        },

        /// Emission schedule has ended (all eras completed)
        EmissionEnded {
            block_number: BlockNumberFor<T>,
            total_eras: u32,
        },
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ERRORS
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::error]
    pub enum Error<T> {
        /// Could not find block author
        NoAuthor,
        /// Arithmetic overflow
        Overflow,
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HOOKS - Where the magic happens
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::hooks]
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        /// Called at the start of each block
        /// 
        /// This is where we mint and distribute block rewards
        fn on_initialize(block_number: BlockNumberFor<T>) -> Weight {
            // Convert block number to u32 for era calculation
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            
            // Calculate current era (0-indexed)
            // Era 0 = blocks 1-14400, Era 1 = blocks 14401-28800, etc.
            let current_era = block_num.saturating_sub(1) / BLOCKS_PER_ERA;
            
            // Check if we're still within the emission schedule
            if (current_era as usize) >= TOTAL_ERAS {
                // Emission has ended
                if block_num % BLOCKS_PER_ERA == 1 {
                    // Only emit event once per era
                    Self::deposit_event(Event::EmissionEnded {
                        block_number,
                        total_eras: TOTAL_ERAS as u32,
                    });
                }
                return T::WeightInfo::on_initialize_no_reward();
            }

            // Look up reward for this era from the pre-computed table
            let reward_per_block = REWARD_SCHEDULE[current_era as usize];

            // Skip if reward is zero
            if reward_per_block == 0 {
                return T::WeightInfo::on_initialize_no_reward();
            }

            // Convert to balance type
            let reward: BalanceOf<T> = match reward_per_block.try_into() {
                Ok(r) => r,
                Err(_) => return T::WeightInfo::on_initialize_no_reward(),
            };

            // Find the block author (validator)
            // We use an empty iterator since we rely on the FindAuthor implementation
            // to determine the author from block digests
            let digests: alloc::vec::Vec<(frame_support::ConsensusEngineId, &[u8])> = Default::default();
            let author = match T::FindAuthor::find_author(digests) {
                Some(a) => a,
                None => return T::WeightInfo::on_initialize_no_reward(),
            };

            // Mint the reward (create new tokens)
            let imbalance = T::Currency::deposit_creating(&author, reward);

            // Emit event
            Self::deposit_event(Event::RewardMinted {
                block_number,
                era: current_era,
                author: author.clone(),
                reward,
            });

            // Drop imbalance to finalize the mint
            drop(imbalance);

            T::WeightInfo::on_initialize_with_reward()
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    impl<T: Config> Pallet<T> {
        /// Get the current era based on block number
        pub fn current_era(block_number: BlockNumberFor<T>) -> u32 {
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            block_num.saturating_sub(1) / BLOCKS_PER_ERA
        }

        /// Get reward per block for a given era
        pub fn reward_for_era(era: u32) -> u128 {
            if (era as usize) < TOTAL_ERAS {
                REWARD_SCHEDULE[era as usize]
            } else {
                0
            }
        }

        /// Get maximum supply
        pub fn max_supply() -> u128 {
            MAX_SUPPLY
        }

        /// Get total eras in emission schedule
        pub fn total_eras() -> u32 {
            TOTAL_ERAS as u32
        }

        /// Check if emission has ended
        pub fn is_emission_ended(block_number: BlockNumberFor<T>) -> bool {
            Self::current_era(block_number) >= TOTAL_ERAS as u32
        }

        /// Get estimated total emission so far
        pub fn total_emitted(block_number: BlockNumberFor<T>) -> u128 {
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            let current_era = Self::current_era(block_number) as usize;
            
            let mut total: u128 = 0;
            
            // Sum all complete eras
            for era in 0..current_era.min(TOTAL_ERAS) {
                total = total.saturating_add(
                    REWARD_SCHEDULE[era].saturating_mul(BLOCKS_PER_ERA as u128)
                );
            }
            
            // Add partial current era
            if current_era < TOTAL_ERAS {
                let blocks_in_era = block_num.saturating_sub(
                    (current_era as u32).saturating_mul(BLOCKS_PER_ERA)
                );
                total = total.saturating_add(
                    REWARD_SCHEDULE[current_era].saturating_mul(blocks_in_era as u128)
                );
            }
            
            total
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// WEIGHTS
// ═══════════════════════════════════════════════════════════════════════════

use frame_support::weights::Weight;

/// Weight functions for pallet-emission
pub trait WeightInfo {
    fn on_initialize_with_reward() -> Weight;
    fn on_initialize_no_reward() -> Weight;
}

/// Default weights (to be benchmarked)
impl WeightInfo for () {
    fn on_initialize_with_reward() -> Weight {
        // Estimate: read era, lookup table, mint tokens, emit event
        Weight::from_parts(15_000_000, 1024)
    }

    fn on_initialize_no_reward() -> Weight {
        // Estimate: just check if emission ended
        Weight::from_parts(5_000_000, 512)
    }
}
