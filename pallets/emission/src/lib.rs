//! # Tesserax Emission Pallet (v3.0)
//!
//! A **stateless** pallet that distributes block rewards according to a
//! pre-computed sigmoid emission schedule, plus a one-time bonus mint.
//!
//! ## Design Philosophy
//!
//! Unlike the complex ASM (Adaptive Scarcity Mechanism) in v1.0, this pallet
//! uses a simple lookup table approach:
//!
//! 1. Emission schedule is pre-computed off-chain (Python script)
//! 2. Reward per era is stored in a constant array
//! 3. On each block, the pallet looks up the current era's reward
//! 4. Reward is minted and given to the block author
//! 5. After emission ends, a bonus of 627 TSRX is minted once
//!
//! ## Why Pre-computed?
//!
//! - **Deterministic**: No floating-point, no approximation errors
//! - **Auditable**: Anyone can verify the exact emission schedule
//! - **Simple**: No complex on-chain math, just array lookup
//! - **Gas-efficient**: O(1) lookup vs O(n) computation
//!
//! ## Emission Curve
//!
//! The sigmoid function produces a bell-curve reward distribution:
//! - Years 0-5: Rewards increase (early adopter incentive)
//! - Year 10: Peak rewards (~0.66 TSRX/block)
//! - Years 15-20: Rewards decrease (scarcity phase)
//! - Post-Year 20: Bonus mint of 627 TSRX (one-time only)
//!
//! Total supply reaches exactly 13,817,580 TSRX (π × e × φ × 10^6)

#![cfg_attr(not(feature = "std"), no_std)]

extern crate alloc;

pub use pallet::*;

/// Pre-computed emission table (generated by scripts/generate_curve.py)
mod emission_table;
pub use emission_table::*;

/// Weight implementations
pub mod weights;
pub use weights::*;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame_support::pallet]
pub mod pallet {
    use super::*;
    use frame_support::{
        pallet_prelude::*,
        traits::{Currency, FindAuthor},
    };
    use frame_system::pallet_prelude::*;

    /// The balance type of this pallet
    pub type BalanceOf<T> =
        <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;

    /// Negative imbalance (newly created tokens)
    pub type NegativeImbalanceOf<T> = <<T as Config>::Currency as Currency<
        <T as frame_system::Config>::AccountId,
    >>::NegativeImbalance;

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    /// Configuration trait for the emission pallet.
    /// 
    /// Note: `RuntimeEvent: From<Event<Self>>` is automatically appended by the pallet macro.
    #[pallet::config]
    pub trait Config: frame_system::Config {

        /// Currency for reward distribution
        type Currency: Currency<Self::AccountId>;

        /// Find the author of the current block (validator who gets reward)
        type FindAuthor: FindAuthor<Self::AccountId>;

        /// Weight information
        type WeightInfo: WeightInfo;
    }

    // ═══════════════════════════════════════════════════════════════════════
    // STORAGE
    // ═══════════════════════════════════════════════════════════════════════

    /// Flag to track if bonus has been minted (one-time only)
    /// This ensures the 627 TSRX bonus is only minted once after emission ends
    #[pallet::storage]
    #[pallet::getter(fn bonus_minted)]
    pub type BonusMinted<T> = StorageValue<_, bool, ValueQuery>;

    // ═══════════════════════════════════════════════════════════════════════
    // EVENTS
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Block reward was minted and distributed to the block author
        RewardMinted {
            block_number: BlockNumberFor<T>,
            era: u32,
            author: T::AccountId,
            reward: BalanceOf<T>,
        },

        /// Emission schedule has ended (all eras completed)
        EmissionEnded {
            block_number: BlockNumberFor<T>,
            total_eras: u32,
        },

        /// Bonus amount minted to reach 100% of max supply
        BonusMinted {
            block_number: BlockNumberFor<T>,
            recipient: T::AccountId,
            amount: BalanceOf<T>,
        },
    }

    // ═══════════════════════════════════════════════════════════════════════
    // ERRORS
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::error]
    pub enum Error<T> {
        /// Could not find block author
        NoAuthor,
        /// Arithmetic overflow
        Overflow,
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HOOKS - Where the magic happens
    // ═══════════════════════════════════════════════════════════════════════

    #[pallet::hooks]
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        /// Called at the start of each block
        /// 
        /// This is where we mint and distribute block rewards
        fn on_initialize(block_number: BlockNumberFor<T>) -> Weight {
            // Convert block number to u32 for era calculation
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            
            // Calculate current era (0-indexed)
            // Era 0 = blocks 1-14400, Era 1 = blocks 14401-28800, etc.
            let current_era = block_num.saturating_sub(1) / BLOCKS_PER_ERA;
            
            // Check if we're still within the emission schedule
            if (current_era as usize) >= TOTAL_ERAS {
                // Emission has ended - check if bonus needs to be minted
                if !BonusMinted::<T>::get() {
                    // Mint bonus amount once to reach 100% of max supply
                    let bonus: BalanceOf<T> = match BONUS_AMOUNT.try_into() {
                        Ok(b) => b,
                        Err(_) => return T::WeightInfo::on_initialize_no_reward(),
                    };

                    // Find the block author (or use first validator if not found)
                    let digests: alloc::vec::Vec<(frame_support::ConsensusEngineId, &[u8])> = Default::default();
                    let recipient = match T::FindAuthor::find_author(digests) {
                        Some(author) => author,
                        None => return T::WeightInfo::on_initialize_no_reward(),
                    };

                    // Mint the bonus
                    let imbalance = T::Currency::deposit_creating(&recipient, bonus);
                    drop(imbalance);

                    // Set flag to prevent duplicate minting
                    BonusMinted::<T>::put(true);

                    // Emit events
                    Self::deposit_event(Event::BonusMinted {
                        block_number,
                        recipient: recipient.clone(),
                        amount: bonus,
                    });

                    Self::deposit_event(Event::EmissionEnded {
                        block_number,
                        total_eras: TOTAL_ERAS as u32,
                    });

                    return T::WeightInfo::on_initialize_with_reward();
                }

                // Bonus already minted
                if block_num % BLOCKS_PER_ERA == 1 {
                    // Only emit event once per era
                    Self::deposit_event(Event::EmissionEnded {
                        block_number,
                        total_eras: TOTAL_ERAS as u32,
                    });
                }
                return T::WeightInfo::on_initialize_no_reward();
            }

            // Look up reward for this era from the pre-computed table
            let reward_per_block = REWARD_SCHEDULE[current_era as usize];

            // Skip if reward is zero
            if reward_per_block == 0 {
                return T::WeightInfo::on_initialize_no_reward();
            }

            // Convert to balance type
            let reward: BalanceOf<T> = match reward_per_block.try_into() {
                Ok(r) => r,
                Err(_) => return T::WeightInfo::on_initialize_no_reward(),
            };

            // Find the block author (validator)
            // We use an empty iterator since we rely on the FindAuthor implementation
            // to determine the author from block digests
            let digests: alloc::vec::Vec<(frame_support::ConsensusEngineId, &[u8])> = Default::default();
            let author = match T::FindAuthor::find_author(digests) {
                Some(a) => a,
                None => return T::WeightInfo::on_initialize_no_reward(),
            };

            // Mint the reward (create new tokens)
            let imbalance = T::Currency::deposit_creating(&author, reward);

            // Emit event
            Self::deposit_event(Event::RewardMinted {
                block_number,
                era: current_era,
                author: author.clone(),
                reward,
            });

            // Drop imbalance to finalize the mint
            drop(imbalance);

            T::WeightInfo::on_initialize_with_reward()
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // HELPER FUNCTIONS
    // ═══════════════════════════════════════════════════════════════════════

    impl<T: Config> Pallet<T> {
        /// Get the current era based on block number
        pub fn current_era(block_number: BlockNumberFor<T>) -> u32 {
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            block_num.saturating_sub(1) / BLOCKS_PER_ERA
        }

        /// Get reward per block for a given era
        pub fn reward_for_era(era: u32) -> u128 {
            if (era as usize) < TOTAL_ERAS {
                REWARD_SCHEDULE[era as usize]
            } else {
                0
            }
        }

        /// Get maximum supply
        pub fn max_supply() -> u128 {
            MAX_SUPPLY
        }

        /// Get total eras in emission schedule
        pub fn total_eras() -> u32 {
            TOTAL_ERAS as u32
        }

        /// Check if emission has ended
        pub fn is_emission_ended(block_number: BlockNumberFor<T>) -> bool {
            Self::current_era(block_number) >= TOTAL_ERAS as u32
        }

        /// Get estimated total emission so far
        pub fn total_emitted(block_number: BlockNumberFor<T>) -> u128 {
            let block_num: u32 = block_number.try_into().unwrap_or(0);
            let current_era = Self::current_era(block_number) as usize;
            
            let mut total: u128 = 0;
            
            // Sum all complete eras
            for era in 0..current_era.min(TOTAL_ERAS) {
                total = total.saturating_add(
                    REWARD_SCHEDULE[era].saturating_mul(BLOCKS_PER_ERA as u128)
                );
            }
            
            // Add partial current era
            if current_era < TOTAL_ERAS {
                let blocks_in_era = block_num.saturating_sub(
                    (current_era as u32).saturating_mul(BLOCKS_PER_ERA)
                );
                total = total.saturating_add(
                    REWARD_SCHEDULE[current_era].saturating_mul(blocks_in_era as u128)
                );
            }
            
            total
        }
    }
}
